<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Iterables & Looping</title>
</head>
<body>
  <p>Hi I'm p 01</p>
<script>
  const cuts = ['It Takes A Nation Of Millions', 'Daily Operation', 'The Chronic', 'Strictly Business'];

  // lets loop over cuts with a traditional for loop:
  /* some of the downsides here are: 
    * its a lot visually going on with the arguments to for
    * its generally not very readable, you dont have a variable
      called `cut` from `cuts`, you have to use cuts[i]  
  */
  // for (let i = 0; i < cuts.length; i++) {
  //   console.log('cuts[i]:', cuts[i]);
  // }

  // we can also use the forEach array method:
  // downwide of this approach is we cant abort the loop
  // and we cannot skip one of the items by using `break`
  // because the `break` statement is not allowed in the
  // forEach method, same goes for `continue`
  // cuts.forEach(cut => console.log('forEach cut: ', cut));

  /* 
    now we also have the for-in loop:
    one of the big downsides to this is if you are working
    with prototypes by adding methods, they will be included
    in the items the for in loops over which you may not want
    or be expecting (my summary of wes' example in the video)
  */

  // for (const cut in cuts) {
  //   console.log('cut: ', cuts[cut]);
  // }

  // now we come to our for of loop, which gives us all the 
  // best of the three loop worlds:
  // caveat: you cant use for of on objects
  // be sure to use const on `cut` or it will leak into the 
  // global scope

  // for (const cut of cuts) {
  //   // console.log('cut of cuts: ', cut);
  //   // we can exit out with for-of:
  //   // if (cut === 'Daily Operation') {
  //   //   // console.log('Gang Starr');
  //   //   break;
  //   // }

  //   // we can also skip over an item[s]
  //   // this will cause this item to be continued over
  //   // and it wont show up as an item in the log following it
  //   if (cut === 'It Takes A Nation Of Millions') {
  //     // console.log('PE');
  //     continue;
  //   }
  //   console.log('cut: ', cut);
  // }

  // generators
  // if we attach an array (cuts) to the entries
  // method, it will give us an arrayIterator()
  // which has a next method, so lets store that in a variable
  // and use it - each time you call the arrayIterator via the 
  // next method it will return the index and value of the next item
  
  // const tracks = cuts.entries();
  // tracks.next();
  // tracks.next();
  // tracks.next();

  // now if we iterate over the cuts array with the arrayIterator,
  // we can then immediately destructure the index and valueitems 
  // into their own variables

  // for of is the loop of choice in every situation with the 
  // exception of objects.

  // for (const [i, cut] of cuts.entries()) {
  //   console.log(`${cut} is the ${i + 1} item`);
  // }

  // for (const [i, cut] of cuts.entries()) {
  //   console.log(`${cut} is the ${i + 1} item`);
  // }

  /*
    for-of is also useful when you need to iterate over
    the arguments object. lets say we have an addUpNumbers
    function and we have no idea how many numbers are going
    to be passed in to that function. so we can access those
    arguments via the arguments keyword with returns an array like
    object that we can loop over with our for-of loop
    
  */

  function addUpNumbers() {
    let total = 0;
    for (num of arguments) {
      total += num;
    }
    console.log('total: ', total);
    return total;
  }

  const thing = addUpNumbers(2, 5, 34, 567, 98);

  // function addUpNumbers() {
  //   let total = 0;
  //   for (const num of arguments) {
  //     total += num;
  //   }
  //   console.log(total);
  //   return total;
  // }

  // addUpNumbers(10,23,52,34,12,13,123);

  // const name = 'Wes Bos';
  // for (const char of name) {
  //   console.log(char);
  // }

  const ps = document.querySelectorAll('p');
  for (const paragraph of ps) {
    paragraph.addEventListener('click', function() {
      console.log(this.textContent);
    });
  }

</script>
</body>
</html>
